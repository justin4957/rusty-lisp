<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="Lisp Compiler Documentation">
    <title>Lisp Compiler Documentation</title>
    <link rel="stylesheet" href="css/docs.css">
    <script src="js/docs.js" defer></script>
</head>
<body class="sidebar-open">
    <div class="sidebar">
        <div class="sidebar-header">
            <h1 class="sidebar-title">
                <a href="index.html">Lisp Compiler</a>
            </h1>
            <span class="sidebar-version">v0.0.1</span>
        </div>
        <nav class="sidebar-nav">
            <ul class="sidebar-nav-list">
                <li class="sidebar-nav-item">
                    <a href="#overview" class="sidebar-nav-link">Overview</a>
                </li>
                <li class="sidebar-nav-item">
                    <a href="#getting-started" class="sidebar-nav-link">Getting Started</a>
                </li>
                <li class="sidebar-nav-item">
                    <a href="#language-reference" class="sidebar-nav-link">Language Reference</a>
                    <ul class="sidebar-subnav">
                        <li><a href="#data-types" class="sidebar-subnav-link">Data Types</a></li>
                        <li><a href="#operations" class="sidebar-subnav-link">Operations</a></li>
                        <li><a href="#control-flow" class="sidebar-subnav-link">Control Flow</a></li>
                    </ul>
                </li>
                <li class="sidebar-nav-item">
                    <a href="#examples" class="sidebar-nav-link">Examples</a>
                </li>
                <li class="sidebar-nav-item">
                    <a href="#json-ir" class="sidebar-nav-link">JSON IR</a>
                </li>
                <li class="sidebar-nav-item">
                    <a href="#validation" class="sidebar-nav-link">AST Validation</a>
                </li>
                <li class="sidebar-nav-item">
                    <a href="#api-reference" class="sidebar-nav-link">API Reference</a>
                    <ul class="sidebar-subnav">
                        <li><a href="#lexer" class="sidebar-subnav-link">Lexer</a></li>
                        <li><a href="#parser" class="sidebar-subnav-link">Parser</a></li>
                        <li><a href="#validator-api" class="sidebar-subnav-link">Validator</a></li>
                        <li><a href="#transform" class="sidebar-subnav-link">Transform</a></li>
                        <li><a href="#compiler" class="sidebar-subnav-link">Compiler</a></li>
                    </ul>
                </li>
            </ul>
        </nav>
    </div>

    <div class="content-wrapper">
        <header class="content-header">
            <div class="content-header-actions">
                <button class="sidebar-toggle" aria-label="Toggle sidebar">
                    <span class="hamburger-line"></span>
                    <span class="hamburger-line"></span>
                    <span class="hamburger-line"></span>
                </button>
            </div>
            <div class="content-header-title">
                <h1>Lisp Compiler Documentation</h1>
                <p class="content-header-subtitle">A Lisp-to-Rust compiler written in Rust</p>
            </div>
        </header>

        <main class="content-main">
            <section id="overview" class="content-section">
                <h2>Overview</h2>
                <p>The Lisp Compiler is a next-generation Lisp-to-Rust compiler that transforms Lisp S-expressions into efficient, native Rust code. Featuring advanced macro parsing capabilities and designed for AI agent code manipulation, the compiler follows a traditional compilation pipeline with lexical analysis, parsing, and code generation phases.</p>
                
                <div class="feature-grid">
                    <div class="feature-card">
                        <h3>üöÄ Fast Compilation</h3>
                        <p>Direct compilation to native Rust code for maximum performance</p>
                    </div>
                    <div class="feature-card">
                        <h3>üõ°Ô∏è Type Safety</h3>
                        <p>Leverages Rust's type system for memory safety and reliability</p>
                    </div>
                    <div class="feature-card">
                        <h3>üìù Complete Implementation</h3>
                        <p>Full lexer, parser, and code generator with comprehensive error handling</p>
                    </div>
                    <div class="feature-card">
                        <h3>üß™ Well Tested</h3>
                        <p>Extensive test suite covering all language features</p>
                    </div>
                    <div class="feature-card">
                        <h3>üîß Macro System</h3>
                        <p>Complete macro infrastructure: defmacro with &rest parameters, quote family, comprehensive error handling with actionable messages, pipeline-integrated expansion engine, and automatic hygiene</p>
                    </div>
                    <div class="feature-card">
                        <h3>üîå AST Transform Hooks</h3>
                        <p>Extensible plugin system for AST manipulation between parsing and macro expansion. Perfect for AI agents, refactoring tools, and code instrumentation</p>
                    </div>
                    <div class="feature-card">
                        <h3>üìä JSON Intermediate Representation</h3>
                        <p>Full JSON serialization/deserialization of AST. AI-friendly format for LLM code generation, external tooling, and round-trip transformations</p>
                    </div>
                    <div class="feature-card">
                        <h3>üõ°Ô∏è AST Validation Engine</h3>
                        <p>Comprehensive safety validation with type checking, resource bounds analysis, FFI restrictions, and complexity limits. Critical for ensuring AI-generated code is safe before execution</p>
                    </div>
                    <div class="feature-card">
                        <h3>üîí Sandbox Environment</h3>
                        <p>Secure execution environment with capability-based security, resource limits, and runtime monitoring. Provides defense-in-depth for running untrusted AI-generated code safely</p>
                    </div>
                </div>
            </section>

            <section id="getting-started" class="content-section">
                <h2>Getting Started</h2>
                
                <h3>Installation</h3>
                <div class="code-block">
                    <pre><code class="language-bash">git clone &lt;repository-url&gt;
cd lisp-compiler
cargo build --release</code></pre>
                </div>

                <h3>Basic Usage</h3>
                <p>Create a Lisp file and compile it to Rust:</p>
                
                <div class="example-block">
                    <div class="example-header">
                        <span class="example-title">example.lisp</span>
                    </div>
                    <div class="code-block">
                        <pre><code class="language-lisp">(+ 1 2 3)
(* (+ 2 3) 4)
(if (&gt; 10 5) "greater" "less")</code></pre>
                    </div>
                </div>

                <div class="code-block">
                    <pre><code class="language-bash"># Compile to Rust
cargo run example.lisp &gt; output.rs

# With AST transforms
cargo run -- --transforms echo example.lisp &gt; output.rs

# Convert to JSON IR
cargo run -- --to-ir example.lisp &gt; example.ir.json

# Compile JSON IR to Rust
cargo run -- --from-ir example.ir.json &gt; output.rs

# With validation (recommended for AI-generated code)
cargo run -- --validate-safety example.lisp &gt; output.rs

# With sandbox (secure AI code execution)
cargo run -- --sandbox-mode example.lisp &gt; output.rs
cargo run -- --sandbox-mode --max-memory=100MB --timeout=30s example.lisp

# Maximum security: validation + sandbox
cargo run -- --sandbox-mode --validate-safety example.lisp

# Compile and run
rustc output.rs -o program && ./program</code></pre>
                </div>

                <div class="output-block">
                    <div class="output-header">Output</div>
                    <pre><code>6
20
"greater"</code></pre>
                </div>
            </section>

            <section id="language-reference" class="content-section">
                <h2>Language Reference</h2>

                <h3 id="data-types">Data Types</h3>
                <div class="data-types-grid">
                    <div class="data-type-card">
                        <h4>Numbers</h4>
                        <div class="code-block">
                            <pre><code class="language-lisp">42      ; Integer
3.14    ; Float  
-10     ; Negative</code></pre>
                        </div>
                    </div>
                    <div class="data-type-card">
                        <h4>Strings</h4>
                        <div class="code-block">
                            <pre><code class="language-lisp">"hello world"
"with\nnewlines"
"escaped \"quotes\""</code></pre>
                        </div>
                    </div>
                    <div class="data-type-card">
                        <h4>Booleans & Nil</h4>
                        <div class="code-block">
                            <pre><code class="language-lisp">true
false
nil</code></pre>
                        </div>
                    </div>
                    <div class="data-type-card">
                        <h4>Symbols</h4>
                        <div class="code-block">
                            <pre><code class="language-lisp">x
my-variable
+
custom-func</code></pre>
                        </div>
                    </div>
                </div>

                <h3 id="operations">Operations</h3>
                
                <h4>Arithmetic Operations</h4>
                <div class="operation-table">
                    <table>
                        <thead>
                            <tr>
                                <th>Operation</th>
                                <th>Lisp Syntax</th>
                                <th>Generated Rust</th>
                                <th>Result</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>Addition</td>
                                <td><code>(+ 1 2 3)</code></td>
                                <td><code>(1 + 2 + 3)</code></td>
                                <td>6</td>
                            </tr>
                            <tr>
                                <td>Subtraction</td>
                                <td><code>(- 10 3)</code></td>
                                <td><code>(10 - 3)</code></td>
                                <td>7</td>
                            </tr>
                            <tr>
                                <td>Multiplication</td>
                                <td><code>(* 4 5 2)</code></td>
                                <td><code>(4 * 5 * 2)</code></td>
                                <td>40</td>
                            </tr>
                            <tr>
                                <td>Division</td>
                                <td><code>(/ 20 4)</code></td>
                                <td><code>(20 / 4)</code></td>
                                <td>5</td>
                            </tr>
                        </tbody>
                    </table>
                </div>

                <h4>Comparison Operations</h4>
                <div class="operation-table">
                    <table>
                        <thead>
                            <tr>
                                <th>Operation</th>
                                <th>Lisp Syntax</th>
                                <th>Generated Rust</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>Equal</td>
                                <td><code>(= 5 5)</code></td>
                                <td><code>(5 == 5)</code></td>
                            </tr>
                            <tr>
                                <td>Less Than</td>
                                <td><code>(&lt; 3 7)</code></td>
                                <td><code>(3 &lt; 7)</code></td>
                            </tr>
                            <tr>
                                <td>Greater Than</td>
                                <td><code>(&gt; 8 2)</code></td>
                                <td><code>(8 &gt; 2)</code></td>
                            </tr>
                            <tr>
                                <td>Less or Equal</td>
                                <td><code>(&lt;= 4 4)</code></td>
                                <td><code>(4 &lt;= 4)</code></td>
                            </tr>
                            <tr>
                                <td>Greater or Equal</td>
                                <td><code>(&gt;= 9 5)</code></td>
                                <td><code>(9 &gt;= 5)</code></td>
                            </tr>
                        </tbody>
                    </table>
                </div>

                <h3 id="control-flow">Control Flow</h3>
                
                <h4>Conditionals</h4>
                <div class="example-block">
                    <div class="example-header">
                        <span class="example-title">If Expression</span>
                    </div>
                    <div class="code-block">
                        <pre><code class="language-lisp">(if (&gt; x 0) 
    "positive" 
    "non-positive")</code></pre>
                    </div>
                    <div class="example-output">
                        <strong>Compiles to:</strong>
                        <pre><code class="language-rust">if x &gt; 0 { "positive" } else { "non-positive" }</code></pre>
                    </div>
                </div>

                <h4>Variable Binding</h4>
                <div class="example-block">
                    <div class="example-header">
                        <span class="example-title">Let Expression</span>
                    </div>
                    <div class="code-block">
                        <pre><code class="language-lisp">(let ((x 10) (y 20)) 
     (+ x y))</code></pre>
                    </div>
                    <div class="example-output">
                        <strong>Compiles to:</strong>
                        <pre><code class="language-rust">{ let x = 10; let y = 20; (x + y) }</code></pre>
                    </div>
                </div>
            </section>

            <section id="examples" class="content-section">
                <h2>Examples</h2>
                
                <div class="example-grid">
                    <div class="example-card">
                        <h3>Mathematical Calculations</h3>
                        <div class="code-block">
                            <pre><code class="language-lisp">; Calculate area of triangle
(let ((base 5) (height 10))
     (* 0.5 base height))

; Quadratic formula
(let ((a 1) (b -5) (c 6))
     (/ (+ (- b) (sqrt (- (* b b) (* 4 a c))))
        (* 2 a)))</code></pre>
                        </div>
                    </div>
                    
                    <div class="example-card">
                        <h3>Conditional Logic</h3>
                        <div class="code-block">
                            <pre><code class="language-lisp">; Grade assignment
(if (&gt;= score 90) 
    "A"
    (if (&gt;= score 80)
        "B" 
        (if (&gt;= score 70)
            "C"
            "F")))

; Min/max functions
(if (&lt; a b) a b)  ; min
(if (&gt; a b) a b)  ; max</code></pre>
                        </div>
                    </div>
                    
                    <div class="example-card">
                        <h3>List Operations</h3>
                        <div class="code-block">
                            <pre><code class="language-lisp">; Create lists
(list 1 2 3 4 5)
(list "hello" "world")
(list true false nil)

; Nested lists  
(list (list 1 2) (list 3 4))</code></pre>
                        </div>
                    </div>
                    
                    <div class="example-card">
                        <h3>Macro Definitions & Expansion</h3>
                        <div class="code-block">
                            <pre><code class="language-lisp">; Simple macro with automatic expansion
(defmacro double (x)
  `(* ,x 2))

(double 5)  ; Expands to: (* 5 2)

; Nested macro expansion
(defmacro quadruple (x)
  `(double (double ,x)))

(quadruple 3)  ; Expands to: (* (* 3 2) 2)

; Macro with multiple parameters
(defmacro add-and-multiply (a b c)
  `(* (+ ,a ,b) ,c))

(add-and-multiply 1 2 3)  ; Expands to: (* (+ 1 2) 3)</code></pre>
                        </div>

                        <p><em>Macro expansion engine fully integrated into compilation pipeline with parameter substitution, recursive expansion, comprehensive error handling with actionable suggestions, and automatic hygiene to prevent variable capture</em></p>
                    </div>

                    <div class="example-card">
                        <h3>Pattern Matching with &rest Parameters</h3>
                        <div class="code-block">
                            <pre><code class="language-lisp">; Variadic macros with &rest
(defmacro add-all (first &rest rest)
  `(+ ,first ,@rest))

(add-all 1 2 3 4 5)  ; Expands to: (+ 1 2 3 4 5)

; Classic when macro with multiple body expressions
(defmacro when (condition &rest body)
  `(if ,condition (progn ,@body) nil))

(when (> x 5)
  (print "big")
  (+ x 1))
; Expands to: (if (> x 5) (progn (print "big") (+ x 1)) nil)</code></pre>
                        </div>
                        <p><em>Advanced parameter patterns support variable-length argument lists with &rest</em></p>
                    </div>

                    <div class="example-card">
                        <h3>Quote Family Syntax</h3>
                        <div class="code-block">
                            <pre><code class="language-lisp">; Quote (data as literal)
'(+ 1 2 3)
(quote (+ 1 2 3))

; Quasiquote (template with holes)
`(+ ,x ,(* 2 y))
(quasiquote (+ (unquote x) (unquote (* 2 y))))

; Splicing (unpack lists)  
`(list ,@items)
(quasiquote (list (unquote-splicing items)))</code></pre>
                        </div>
                        <p><em>Both shorthand and longhand forms supported</em></p>
                    </div>
                </div>
            </section>

            <section id="json-ir" class="content-section">
                <h2>JSON Intermediate Representation</h2>
                <p>The compiler supports JSON serialization and deserialization of the AST, providing an AI-friendly format for code generation and manipulation.</p>

                <h3>Benefits for AI Agents</h3>
                <ul>
                    <li><strong>Easier Generation:</strong> LLMs excel at producing valid JSON vs. Lisp syntax</li>
                    <li><strong>Error Reduction:</strong> Structured data reduces parsing failures</li>
                    <li><strong>Tool Integration:</strong> External analysis and transformation tools can work with JSON</li>
                    <li><strong>Debugging:</strong> Human-readable JSON format for AST inspection</li>
                </ul>

                <h3>JSON Format</h3>
                <p>The AST is serialized using serde's default enum representation. Each variant is represented as an object with a single key:</p>

                <div class="example-card">
                    <h4>Simple Expression</h4>
                    <div class="code-block">
                        <pre><code class="language-lisp">; Lisp input
(+ 1 2)</code></pre>
                    </div>
                    <div class="code-block">
                        <pre><code class="language-json">// JSON IR output
[
  {
    "List": [
      { "Symbol": "+" },
      { "Number": 1.0 },
      { "Number": 2.0 }
    ]
  }
]</code></pre>
                    </div>
                </div>

                <h3>Supported AST Variants</h3>
                <div class="api-section">
                    <ul>
                        <li><strong>Atoms:</strong> <code>{"Number": 42.0}</code>, <code>{"Symbol": "foo"}</code>, <code>{"String": "hello"}</code>, <code>{"Bool": true}</code>, <code>"Nil"</code></li>
                        <li><strong>Lists:</strong> <code>{"List": [...]}</code></li>
                        <li><strong>Macros:</strong> <code>{"Macro": {"name": "...", "parameters": [...], "body": {...}}}</code></li>
                        <li><strong>Quote Family:</strong> <code>{"Quote": {...}}</code>, <code>{"Quasiquote": {...}}</code>, <code>{"Unquote": {...}}</code>, <code>{"Splice": {...}}</code></li>
                        <li><strong>Hygiene:</strong> <code>{"Gensym": "unique_123"}</code></li>
                    </ul>
                </div>

                <h3>Round-trip Example</h3>
                <div class="code-block">
                    <pre><code class="language-bash"># 1. Convert Lisp to JSON IR
cargo run -- --to-ir example.lisp &gt; example.ir.json

# 2. Compile JSON IR to Rust
cargo run -- --from-ir example.ir.json &gt; output.rs

# 3. Run the generated code
rustc output.rs && ./output</code></pre>
                </div>

                <div class="example-card">
                    <h4>Complete Workflow</h4>
                    <div class="code-block">
                        <pre><code class="language-bash">$ echo "(+ 1 (* 2 3))" &gt; example.lisp

$ cargo run -- --to-ir example.lisp
[
  {
    "List": [
      { "Symbol": "+" },
      { "Number": 1.0 },
      {
        "List": [
          { "Symbol": "*" },
          { "Number": 2.0 },
          { "Number": 3.0 }
        ]
      }
    ]
  }
]

$ cargo run -- --to-ir example.lisp | cargo run -- --from-ir /dev/stdin
fn main() {
    println!("{:?}", (1 + (2 * 3)));
}</code></pre>
                    </div>
                </div>
            </section>

            <section id="validation" class="content-section">
                <h2>AST Validation Engine</h2>
                <p>The validation engine provides comprehensive safety checks for AST structures before compilation. This is especially critical for AI-generated code to prevent common errors and unsafe operations.</p>

                <h3>Validation Rules</h3>
                <div class="api-section">
                    <h4>Type Safety</h4>
                    <p>Detects type mismatches in operations (e.g., adding strings to numbers).</p>
                    <div class="code-block">
                        <pre><code class="language-lisp">; Invalid - will fail validation
(+ "hello" 42)

; Error: Type mismatch: arithmetic operation '+' requires numeric operands, got String</code></pre>
                    </div>

                    <h4>Resource Bounds</h4>
                    <p>Catches infinite loops and unbounded recursion patterns.</p>
                    <div class="code-block">
                        <pre><code class="language-lisp">; Invalid - obvious infinite recursion
(define (infinite-loop) (infinite-loop))

; Error: Infinite recursion detected: function 'infinite-loop' calls itself
;        without any conditional base case</code></pre>
                    </div>

                    <h4>FFI Restrictions</h4>
                    <p>Controls access to unsafe Rust operations and FFI calls.</p>
                    <div class="code-block">
                        <pre><code class="language-lisp">; Invalid - unsafe operation not allowed
(rust-unsafe "std::ptr::null()")

; Error: FFI restriction: unsafe operation 'rust-unsafe' is not allowed</code></pre>
                    </div>

                    <h4>Complexity Limits</h4>
                    <p>Prevents overly complex AST structures by limiting nesting depth.</p>
                    <div class="code-block">
                        <pre><code class="language-lisp">; Invalid if nesting exceeds configured limit
(+ (+ (+ (+ (+ ... ))))) ; too deeply nested</code></pre>
                    </div>
                </div>

                <h3>Usage</h3>
                <p>Enable validation with the <code>--validate-safety</code> CLI flag:</p>
                <div class="code-block">
                    <pre><code class="language-bash"># Compile with validation enabled
cargo run -- --validate-safety example.lisp &gt; output.rs</code></pre>
                </div>

                <h3>Validation in the Pipeline</h3>
                <p>Validation runs <strong>before macro expansion</strong> in the compilation pipeline:</p>
                <div class="code-block">
                    <pre><code>Source ‚Üí Parse ‚Üí Transform ‚Üí [VALIDATE] ‚Üí Macro Expand ‚Üí Compile ‚Üí Rust</code></pre>
                </div>

                <div class="api-section">
                    <p>This ensures that:</p>
                    <ul>
                        <li>Invalid code is caught early, before expensive macro expansion</li>
                        <li>Error messages reference the original source code structure</li>
                        <li>AI-generated code is verified for safety before execution</li>
                        <li>Multiple validation errors are reported together for efficient debugging</li>
                    </ul>
                </div>

                <h3>Why Validation Matters for AI</h3>
                <p>AI-generated code can contain subtle errors that are syntactically correct but semantically invalid:</p>
                <div class="api-section">
                    <ul>
                        <li><strong>Type errors:</strong> LLMs may mix incompatible types in operations</li>
                        <li><strong>Infinite loops:</strong> Generated recursive functions may lack base cases</li>
                        <li><strong>Unsafe operations:</strong> AI may attempt to generate unsafe Rust code</li>
                        <li><strong>Complex structures:</strong> Generated code may exceed reasonable complexity bounds</li>
                    </ul>
                    <p>The validation engine catches these issues <strong>before compilation</strong>, providing a crucial safety layer for AI-first workflows.</p>
                </div>

                <h3>Example: Valid vs. Invalid Code</h3>
                <div class="example-card">
                    <h4>Valid Code - Passes Validation</h4>
                    <div class="code-block">
                        <pre><code class="language-bash">$ cat example.lisp
(+ 1 (* 2 3))

$ cargo run -- --validate-safety example.lisp
fn main() {
    println!("{:?}", (1 + (2 * 3)));
}</code></pre>
                    </div>
                </div>

                <div class="example-card">
                    <h4>Invalid Code - Fails Validation</h4>
                    <div class="code-block">
                        <pre><code class="language-bash">$ cat invalid.lisp
(+ "string" 42)

$ cargo run -- --validate-safety invalid.lisp
Compilation error: Validation failed with 1 error(s):
  - TypeSafety violation: Type mismatch: arithmetic operation '+'
    requires numeric operands, got String
    Context: String("string")</code></pre>
                    </div>
                </div>

                <h3>Composable Validator Architecture</h3>
                <p>The validation system uses a plugin architecture that allows combining multiple validation rules:</p>
                <div class="code-block">
                    <pre><code class="language-rust">// Validators can be composed
let composite_validator = CompositeValidator::new()
    .add_validator(Box::new(TypeSafetyValidator::new()))
    .add_validator(Box::new(ResourceBoundsValidator::new()))
    .add_validator(Box::new(FFIRestrictionsValidator::new()))
    .add_validator(Box::new(ComplexityLimitsValidator::new()));

// Run all validators
composite_validator.validate_all(&ast)?;</code></pre>
                </div>
            </section>

            <section id="sandbox" class="content-section">
                <h2>Sandbox Environment</h2>
                <p>The sandbox provides a controlled execution environment for AI-generated code with capability-based security and resource limits. This is crucial for safely running untrusted code from AI agents.</p>

                <h3>Security Model</h3>
                <p>The sandbox implements four layers of defense:</p>
                <div class="api-section">
                    <ul>
                        <li><strong>Capability-based permissions</strong> - Explicit grants for specific operations</li>
                        <li><strong>Resource monitoring</strong> - Memory and execution time tracking</li>
                        <li><strong>Safe API surface</strong> - Whitelist of allowed Rust standard library functions</li>
                        <li><strong>Violation detection</strong> - Runtime checks for security boundary breaches</li>
                    </ul>
                </div>

                <h3>Configuration</h3>
                <p>The sandbox is configured via the <code>SandboxConfig</code> struct:</p>
                <div class="code-block">
                    <pre><code class="language-rust">pub struct SandboxConfig {
    max_memory: usize,                    // Maximum memory in bytes
    max_execution_time: Duration,         // Maximum execution time
    allowed_file_paths: Vec&lt;PathBuf&gt;,     // Permitted file paths
    permitted_network_access: bool,       // Network access flag
    safe_rust_apis: HashSet&lt;String&gt;,      // Allowed API whitelist
    capabilities: HashSet&lt;Capability&gt;,    // Granted capabilities
}</code></pre>
                </div>

                <h3>Capabilities</h3>
                <p>Fine-grained permissions for specific operations:</p>
                <div class="code-block">
                    <pre><code class="language-rust">pub enum Capability {
    FileRead(PathBuf),      // Read from specific path
    FileWrite(PathBuf),     // Write to specific path
    NetworkHTTP,            // HTTP network requests
    SystemTime,             // Access system time
    ProcessSpawn,           // Spawn child processes
    UnsafeRust,            // Use unsafe Rust features
}</code></pre>
                </div>

                <h3>CLI Usage</h3>
                <div class="code-block">
                    <pre><code class="language-bash"># Enable sandbox with default settings (100MB, 30s timeout)
cargo run -- --sandbox-mode example.lisp

# Configure resource limits
cargo run -- --sandbox-mode --max-memory=50MB --timeout=10s example.lisp
cargo run -- --sandbox-mode --max-memory=1GB --timeout=5m example.lisp

# Grant specific capabilities
cargo run -- --sandbox-mode --allow-capability=FileRead:/tmp/data example.lisp
cargo run -- --sandbox-mode --allow-capability=FileWrite:/tmp/output example.lisp
cargo run -- --sandbox-mode --allow-capability=NetworkHTTP example.lisp

# Multiple capabilities
cargo run -- --sandbox-mode \
  --allow-capability=FileRead:/tmp \
  --allow-capability=SystemTime \
  example.lisp

# Maximum security: sandbox + validation
cargo run -- --sandbox-mode --validate-safety example.lisp</code></pre>
                </div>

                <h3>Violation Types</h3>
                <p>The sandbox detects and reports various security violations:</p>
                <div class="api-section">
                    <ul>
                        <li><strong>MemoryLimitExceeded</strong> - Attempted allocation exceeds configured limit</li>
                        <li><strong>ExecutionTimeExceeded</strong> - Code execution time exceeds timeout</li>
                        <li><strong>UnauthorizedFileAccess</strong> - Attempted file access without permission</li>
                        <li><strong>UnauthorizedNetworkAccess</strong> - Network access without NetworkHTTP capability</li>
                        <li><strong>UnsafeRustNotPermitted</strong> - Unsafe Rust features without UnsafeRust capability</li>
                        <li><strong>ProcessSpawnNotPermitted</strong> - Process spawning without ProcessSpawn capability</li>
                        <li><strong>DisallowedAPIUsage</strong> - Use of API not in safe whitelist</li>
                        <li><strong>MissingCapability</strong> - Operation requires a capability that wasn't granted</li>
                    </ul>
                </div>

                <h3>Safe API Whitelist</h3>
                <p>Default allowed APIs (extensible):</p>
                <div class="api-section">
                    <ul>
                        <li><strong>Core types:</strong> <code>std::vec::Vec</code>, <code>std::string::String</code>, <code>std::option::Option</code>, <code>std::result::Result</code></li>
                        <li><strong>Collections:</strong> <code>std::collections::HashMap</code>, <code>std::collections::HashSet</code></li>
                        <li><strong>I/O:</strong> <code>std::println</code>, <code>std::print</code>, <code>std::format</code></li>
                        <li><strong>Math:</strong> <code>std::cmp</code>, <code>std::ops</code></li>
                    </ul>
                </div>

                <h3>Example: Sandboxed AI Code Execution</h3>
                <div class="example-card">
                    <h4>Secure Execution with Minimal Permissions</h4>
                    <div class="code-block">
                        <pre><code class="language-bash"># AI generates code that needs file access
# Grant minimal required capability
$ cargo run -- --sandbox-mode \
  --allow-capability=FileRead:/data/input.txt \
  --max-memory=10MB \
  --timeout=5s \
  ai-generated-code.lisp

# If code violates limits, get clear error:
Error: Memory limit exceeded: limit=10485760 bytes, attempted=15000000 bytes</code></pre>
                    </div>
                </div>

                <h3>Why Sandbox Matters for AI</h3>
                <p>AI-generated code poses unique security risks:</p>
                <div class="api-section">
                    <ul>
                        <li><strong>Unbounded resource usage:</strong> AI may generate code with memory leaks or infinite loops</li>
                        <li><strong>Unintended file access:</strong> Generated code may access sensitive files</li>
                        <li><strong>Network operations:</strong> AI code could attempt unauthorized network access</li>
                        <li><strong>Unsafe operations:</strong> Generated code may try to use unsafe Rust features</li>
                    </ul>
                </div>

                <h3>Defense in Depth</h3>
                <p>The sandbox provides multiple security layers:</p>
                <div class="api-section">
                    <ol>
                        <li>Limit resource consumption (memory, time)</li>
                        <li>Restrict file system and network access</li>
                        <li>Enforce safe API usage</li>
                        <li>Detect and report violations clearly</li>
                    </ol>
                    <p>Combined with AST validation, the sandbox creates a <strong>secure-by-default</strong> environment for AI code execution.</p>
                </div>

                <h3>Sandbox Monitor API</h3>
                <p>The runtime monitor tracks resource usage and enforces limits:</p>
                <div class="code-block">
                    <pre><code class="language-rust">pub struct SandboxMonitor {
    config: SandboxConfig,
    start_time: Instant,
    current_memory: usize,
}

impl SandboxMonitor {
    // Check if execution time limit has been exceeded
    pub fn check_time_limit(&self) -> Result&lt;(), SandboxViolation&gt;;

    // Check if memory limit would be exceeded
    pub fn check_memory_limit(&self, allocation_size: usize)
        -> Result&lt;(), SandboxViolation&gt;;

    // Record a memory allocation
    pub fn allocate_memory(&mut self, size: usize)
        -> Result&lt;(), SandboxViolation&gt;;

    // Check if file path access is allowed
    pub fn check_file_access(&self, path: &PathBuf)
        -> Result&lt;(), SandboxViolation&gt;;

    // Check if a capability is granted
    pub fn check_capability(&self, capability: &Capability)
        -> Result&lt;(), SandboxViolation&gt;;

    // Check if an API is allowed
    pub fn check_api_usage(&self, api: &str)
        -> Result&lt;(), SandboxViolation&gt;;
}</code></pre>
                </div>
            </section>

            <section id="api-reference" class="content-section">
                <h2>API Reference</h2>

                <h3 id="lexer">Lexer Module</h3>
                <div class="api-section">
                    <h4><code>tokenize(input: &str) -> Result&lt;Vec&lt;Token&gt;, String&gt;</code></h4>
                    <p>Tokenizes the input string into a vector of tokens. Handles numbers, symbols, strings, parentheses, and comments.</p>
                    
                    <h5>Token Types</h5>
                    <ul>
                        <li><code>LeftParen</code> - Opening parenthesis <code>(</code></li>
                        <li><code>RightParen</code> - Closing parenthesis <code>)</code></li>
                        <li><code>Number(f64)</code> - Numeric literals</li>
                        <li><code>Symbol(String)</code> - Variable and function names</li>
                        <li><code>String(String)</code> - String literals</li>
                        <li><code>Bool(bool)</code> - Boolean values</li>
                        <li><code>Nil</code> - Nil value</li>
                        <li><code>Quote</code> - Quote symbol <code>'</code></li>
                        <li><code>Quasiquote</code> - Quasiquote symbol <code>`</code></li>
                        <li><code>Unquote</code> - Unquote symbol <code>,</code></li>
                        <li><code>Splice</code> - Splice symbol <code>,@</code></li>
                    </ul>
                </div>

                <h3 id="parser">Parser Module</h3>
                <div class="api-section">
                    <h4><code>parse(tokens: Vec&lt;Token&gt;) -> Result&lt;Vec&lt;LispExpr&gt;, String&gt;</code></h4>
                    <p>Parses tokens into an Abstract Syntax Tree (AST) of Lisp expressions.</p>
                    
                    <h5>Expression Types</h5>
                    <ul>
                        <li><code>Number(f64)</code> - Numeric values</li>
                        <li><code>Symbol(String)</code> - Identifiers</li>
                        <li><code>String(String)</code> - String literals</li>
                        <li><code>Bool(bool)</code> - Boolean values</li>
                        <li><code>Nil</code> - Nil value</li>
                        <li><code>List(Vec&lt;LispExpr&gt;)</code> - S-expressions</li>
                        <li><code>Macro { name, parameters, body }</code> - Macro definitions</li>
                        <li><code>MacroCall { name, args }</code> - Macro invocations</li>
                        <li><code>Quote(Box&lt;LispExpr&gt;)</code> - Quoted expressions</li>
                        <li><code>Quasiquote(Box&lt;LispExpr&gt;)</code> - Quasiquoted expressions</li>
                        <li><code>Unquote(Box&lt;LispExpr&gt;)</code> - Unquoted expressions</li>
                        <li><code>Splice(Box&lt;LispExpr&gt;)</code> - Splice operations</li>
                        <li><code>Gensym(String)</code> - Generated symbols</li>
                    </ul>
                </div>

                <h3 id="macro-expander">Macro Expander Module</h3>
                <div class="api-section">
                    <h4><code>MacroExpander::new() -> MacroExpander</code></h4>
                    <p>Creates a new macro expander with default settings (max depth: 100).</p>

                    <h4><code>expand_all(expr: LispExpr) -> Result&lt;LispExpr, MacroError&gt;</code></h4>
                    <p>Expands all macro calls in an expression recursively. The expansion phase is integrated into the compilation pipeline between parsing and code generation. Handles:</p>
                    <ul>
                        <li>Macro definition registration</li>
                        <li>Advanced parameter pattern matching:
                            <ul>
                                <li>Simple parameters: <code>(defmacro double (x) ...)</code></li>
                                <li>&rest parameters: <code>(defmacro add-all (first &rest rest) ...)</code></li>
                                <li>Multiple required + rest: <code>(defmacro foo (a b &rest others) ...)</code></li>
                            </ul>
                        </li>
                        <li>Parameter substitution with splice support (<code>,@rest</code>)</li>
                        <li>Automatic gensym-based hygiene to prevent variable capture</li>
                        <li>Depth limiting to prevent infinite recursion (configurable, default: 100)</li>
                        <li>Recursive expansion for nested macros</li>
                        <li>Quasiquote/unquote/splice operations</li>
                        <li>Validation and clear error messages for pattern mismatches</li>
                        <li>Infinite recursion prevention via depth limits</li>
                    </ul>
                </div>

                <h3 id="validator-api">Validator Module</h3>
                <div class="api-section">
                    <h4><code>ASTValidator trait</code></h4>
                    <p>Trait for implementing composable validation rules. Validators check AST structures for safety issues before compilation.</p>

                    <h5>Methods</h5>
                    <ul>
                        <li><code>fn validate(&self, expr: &LispExpr) -> ValidationResult</code> - Validates an AST expression</li>
                        <li><code>fn enabled_rules(&self) -> Vec&lt;ValidationRule&gt;</code> - Returns enabled validation rules</li>
                    </ul>

                    <h4><code>ValidationRule enum</code></h4>
                    <p>Defines the types of validation checks available:</p>
                    <ul>
                        <li><code>TypeSafety</code> - Basic type inference and type checking</li>
                        <li><code>ResourceBounds</code> - Infinite loop and unbounded recursion detection</li>
                        <li><code>FFIRestrictions</code> - Unsafe Rust operation control</li>
                        <li><code>ComplexityLimits</code> - AST complexity and nesting depth limits</li>
                    </ul>

                    <h4>Built-in Validators</h4>
                    <ul>
                        <li><code>TypeSafetyValidator</code> - Checks for type mismatches in operations</li>
                        <li><code>ResourceBoundsValidator</code> - Detects obvious infinite recursion patterns</li>
                        <li><code>FFIRestrictionsValidator</code> - Restricts access to unsafe operations</li>
                        <li><code>ComplexityLimitsValidator</code> - Enforces maximum nesting depth</li>
                        <li><code>CompositeValidator</code> - Combines multiple validators</li>
                    </ul>

                    <h4><code>ValidationError struct</code></h4>
                    <p>Represents validation failures with context:</p>
                    <ul>
                        <li><code>rule: ValidationRule</code> - Which validation rule failed</li>
                        <li><code>message: String</code> - Error description</li>
                        <li><code>context: Option&lt;String&gt;</code> - Additional context about the error</li>
                    </ul>

                    <h5>Example: Using Validators</h5>
                    <div class="code-block">
                        <pre><code class="language-rust">use validator::{CompositeValidator, TypeSafetyValidator};

// Create composite validator
let validator = CompositeValidator::new()
    .add_validator(Box::new(TypeSafetyValidator::new()))
    .add_validator(Box::new(ResourceBoundsValidator::new()));

// Validate AST
match validator.validate_all(&ast) {
    Ok(()) => println!("Validation passed"),
    Err(errors) => {
        for error in errors {
            eprintln!("Validation error: {}", error);
        }
    }
}</code></pre>
                    </div>

                    <h5>Features</h5>
                    <ul>
                        <li>Composable validators can be combined for comprehensive checks</li>
                        <li>Configurable limits (recursion depth, nesting depth, etc.)</li>
                        <li>FFI allowlists for controlled unsafe operations</li>
                        <li>Multiple error reporting for efficient debugging</li>
                    </ul>
                </div>

                <h3 id="transform">Transform Module</h3>
                <div class="api-section">
                    <h4><code>ASTTransform trait</code></h4>
                    <p>Trait for implementing AST transformation plugins. Transforms are applied between parsing and macro expansion, enabling powerful code manipulations.</p>

                    <h5>Methods</h5>
                    <ul>
                        <li><code>fn name(&self) -> &str</code> - Returns the transform name</li>
                        <li><code>fn transform(&self, ast: &mut LispExpr) -> Result&lt;(), TransformError&gt;</code> - Applies transformation to AST</li>
                    </ul>

                    <h4><code>TransformRegistry</code></h4>
                    <p>Manages and applies multiple transform plugins in sequence.</p>

                    <h5>Methods</h5>
                    <ul>
                        <li><code>new() -> TransformRegistry</code> - Creates empty registry</li>
                        <li><code>register(&mut self, transform: Box&lt;dyn ASTTransform&gt;)</code> - Registers a transform plugin</li>
                        <li><code>apply_all(&self, ast: &mut LispExpr) -> Result&lt;(), TransformError&gt;</code> - Applies all transforms in order</li>
                        <li><code>count(&self) -> usize</code> - Returns number of registered transforms</li>
                        <li><code>transform_names(&self) -> Vec&lt;String&gt;</code> - Returns names of all transforms</li>
                    </ul>

                    <h4><code>EchoTransform</code></h4>
                    <p>Built-in transform that prints AST structure for debugging without modifying the AST.</p>

                    <h5>Usage</h5>
                    <div class="code-block">
                        <pre><code class="language-bash">cargo run -- --transforms echo example.lisp</code></pre>
                    </div>

                    <h5>Use Cases</h5>
                    <ul>
                        <li><strong>AI Agent Refactoring</strong> - Automated code restructuring and optimization</li>
                        <li><strong>Code Instrumentation</strong> - Add logging, metrics, or debugging statements</li>
                        <li><strong>Optimization</strong> - Constant folding, dead code elimination</li>
                        <li><strong>Style Enforcement</strong> - Naming conventions, formatting rules</li>
                        <li><strong>Security Scanning</strong> - Pattern detection, vulnerability checking</li>
                    </ul>

                    <h5>Example Custom Transform</h5>
                    <div class="code-block">
                        <pre><code class="language-rust">use crate::ast::LispExpr;
use crate::transform::{ASTTransform, TransformError};

struct DoubleNumberTransform;

impl ASTTransform for DoubleNumberTransform {
    fn name(&self) -> &str {
        "double"
    }

    fn transform(&self, ast: &mut LispExpr) -> Result&lt;(), TransformError&gt; {
        match ast {
            LispExpr::Number(n) => {
                *n *= 2.0;
                Ok(())
            }
            LispExpr::List(items) => {
                for item in items.iter_mut() {
                    self.transform(item)?;
                }
                Ok(())
            }
            _ => Ok(())
        }
    }
}</code></pre>
                    </div>
                </div>

                <h3 id="compiler">Compiler Module</h3>
                <div class="api-section">
                    <h4><code>compile_to_rust(expressions: &[LispExpr]) -> Result&lt;String, String&gt;</code></h4>
                    <p>Compiles Lisp expressions into Rust source code. Macros are automatically expanded before code generation. The generated code is wrapped in a main function with print statements for each expression result.</p>

                    <h5>Supported Operations</h5>
                    <ul>
                        <li>Arithmetic: <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code></li>
                        <li>Comparison: <code>=</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code></li>
                        <li>Control flow: <code>if</code></li>
                        <li>Variable binding: <code>let</code></li>
                        <li>List creation: <code>list</code></li>
                    </ul>
                </div>
            </section>
        </main>

        <footer class="content-footer">
            <p>&copy; 2024 Lisp Compiler Documentation. Generated with custom documentation generator.</p>
        </footer>
    </div>
</body>
</html>